import sys, os
import pytest
import pandas as pd
import numpy as np
### go 2 levels up and add to path
python_modules_dir = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(os.path.realpath(__file__))), "../../"))
sys.path.insert(0, python_modules_dir)




import variables
# TEST_FN_DIR = os.path.join(os.path.dirname(os.path.abspath(os.path.realpath(__file__))), "test")
PYTEST_FN_DIR = variables.PYTEST_FN_DIR




### parse directory of uWSGI. 2 log files from uWSGI and 2 log files from DBL code
# log_requests.txt  log_settings_and_analysis.txt  log_uwsgi_error.txt  log_uwsgi_requests.txt

@pytest.fixture(scope='module')
def test_dir():
    # dir_ = r"/Users/dblyon/modules/cpr/agotool/app/python/load_test/test_2_workers"
    dir_ = r"/Users/dblyon/modules/cpr/agotool/app/python/testing/flood_requests/test_agotool_v8"
    return dir_

@pytest.fixture(scope='module')
def get_fn_log_DBL_requests():
    fn_log_DBL_requests = "log_requests.txt"
    return fn_log_DBL_requests

@pytest.fixture(scope='module')
def get_fn_log_uWSGI_requests():
    fn_log_uWSGI_requests = "log_uwsgi_requests.txt"
    return fn_log_uWSGI_requests


@pytest.fixture(scope='module')
def dfu(test_dir, get_fn_log_uWSGI_requests):
    """
    get_dfu_DataFrame_uWSGI_requests_log
    """
    log_uwsgi_requests = os.path.join(test_dir, get_fn_log_uWSGI_requests)
    with open(log_uwsgi_requests) as fh:
        pid_l, request_per_pid_l, request_total_l, response_time_l, html_response_code_l, time_of_request_l = [], [], [], [], [], []
        for line in fh:
            pid = line.split("pid: ")[1].split("|")[0]
            pid_l.append(int(pid))
            ls = line.split("req: ")[1].split("/")
            request_per_pid = ls[0]
            request_per_pid_l.append(int(request_per_pid))
            request_total = ls[1].split("]")[0]
            request_total_l.append(int(request_total))
            time_of_request = line.split("[")[2].split("]")[0]
            time_of_request_l.append(time_of_request)
            l = line.split("api => generated")[1]
            ls = l.split("bytes in ")[1].split(" ")
            assert ls[1] == "msecs" # sanity test that milliseconds are reported
            response_time = ls[0]
            response_time_l.append(int(response_time))
            html_response_code = ls[3].split(")")[0]
            html_response_code_l.append(int(html_response_code))
    dfu = pd.DataFrame()
    dfu["PID"] = pid_l
    dfu["requests_per_PID"] = request_per_pid_l
    dfu["requests_total_ms"] = request_total_l
    dfu["response_time"] = response_time_l
    dfu["code"] = html_response_code_l
    dfu["time_of_request"] = pd.to_datetime(time_of_request_l)
    return dfu

@pytest.fixture(scope='module')
def dfr(test_dir, get_fn_log_DBL_requests):
    """
    get_dfr_DataFrame_DBL_requests_log
    log file created by DBL using agotool_stress_test.py which calls parallel_requests.py
    this simply records the datetime before calling a Perl script which sends a request to the aGOtool server
    in contrast to get_DataFrame_uWSGI_requests_log which records the actual response time
        but this log has info if the request was parallel or sequential and also
        contains 'WARNING!' if unexpected non-deterministic results were generated
    """
    log_requests = os.path.join(test_dir, get_fn_log_DBL_requests)
    test_number_list, timestamp_list, warning_list, name_list, request_type_list = [], [], [], [], []
    with open(log_requests) as fh:
        for line in fh:
            ls = line.split()
            try:
                test_number = int(ls[1].split("_")[-1])
            except:
                print("get_DataFrame_DBL_requests_log", line)
                break
            timestamp = " ".join(ls[3:])
            test_number_list.append(test_number)
            timestamp_list.append(timestamp)
            name = "_".join(ls[0:2]).replace("Requesting", "")
            name_list.append(name)
            request_type = ls[0].replace("Requesting", "")
            request_type_list.append(request_type)
    dfr = pd.DataFrame()
    dfr["testnumber"] = test_number_list
    dfr["timestamp"] = pd.to_datetime(timestamp_list)
    dfr["name"] = name_list
    dfr["request_type"] = request_type_list
    dfr = dfr.sort_values("timestamp").reset_index(drop=True)
    # delta --> timedelta in nanoseconds --> convert to milliseconds
    dfr["delta_millisec"] = (dfr["timestamp"].iloc[1:].reset_index(drop=True) - dfr["timestamp"].iloc[:-1].reset_index(drop=True)).apply(lambda x: x.delta / 1e6)
    return dfr

def test_if_warnings(test_dir, get_fn_log_DBL_requests):
    """
    were any 'WARNING!' generated by parallel_requests.py or sequential_requests.py
    """
    log_requests = os.path.join(test_dir, get_fn_log_DBL_requests)
    with open(log_requests) as fh:
        for line in fh:
            assert "WARNING" not in line

def test_HTTP_status_code(dfu):
    """
    are any HTTP status codes other than 200
    """
    response_code_list = sorted(dfu["code"].unique().tolist())
    assert len(response_code_list) == 1
    assert response_code_list[0] == 200

def test_long_response_time(dfu):
    """
    response time above 1 second
    """
    maximum_response_time_in_milli_seconds = dfu["response_time"].max()
    assert maximum_response_time_in_milli_seconds <= 1000

def test_deterministic_results():
    """
    results should always yield the same results

    """
