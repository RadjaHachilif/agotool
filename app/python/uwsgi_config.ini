[uwsgi]
socket = 127.0.0.1:3031
# chdir = /home/foobar/myproject/
# wsgi-file = myproject/wsgi.py
virtualenv = "/mnt/mnemo5/dblyon/install/anaconda3/envs/agotool/bin/uwsgi" # location of python executable
# pythonpath = /path-to-virtualenv/project/lib/python2.7/site-packages
# processes = 4
# threads = 1
stats = 127.0.0.1:9191
lazy-apps = true
### This configuration will tell uWSGI to run up to 10 workers under load. If the app is idle uWSGI will stop workers but it will always leave at least 2 of them running.
# set cheaper algorithm to use, if not set default will be used
cheaper-algo = spare
# minimum number of workers to keep at all times
cheaper = 2
# number of workers to spawn at startup
cheaper-initial = 2
# maximum number of workers that can be spawned
workers = 4
# how many workers should be spawned at a time
cheaper-step = 1
# Worker should finish until timeout is reached
worker-reload-mercy = 60 # seconds (default 60).
# If all workers are busy for cheaper_overload seconds then uWSGI will spawn new workers. When the load is gone it will begin stopping processes one at a time.
cheaper_overload = 60
# soft limit will prevent cheaper from spawning new workers
# if workers total rss memory is equal or higher
# we use 128MB soft limit below (values are in bytes)
cheaper-rss-limit-soft = 30000000000 # (~30 GB, default is 134217728 128 MB) should allow for 4 workers to run synchronously.


############### some notes
### uWSGI
# https://uwsgi-docs.readthedocs.io/en/latest/articles/TheArtOfGracefulReloading.html
#forck --> false
#avoid destroying workers/threads that are still managing requests --> “worker’s mercy” and it has a default value of 60 seconds

# Proxy timeouts: connect -->     Maximum amount of time the proxy will wait for a successful connection.
#            : read -->      Maximum amount of time the server will be able to wait for data before giving up.

# lazy-apps mode instead loads your application one time per worker.

# Chain reloading (lazy apps): use --touch-chain-reload option.
# This is the first approach that improves user experience. When triggered, it will restart one worker at time, and the following worker is not reloaded until the previous one is ready to accept new requests.

# https://uwsgi-docs.readthedocs.io/en/latest/Options.html#reload-on-rss
# reload-on-rss: help: reload if rss memory is higher than specified megabytes

# https://uwsgi-docs.readthedocs.io/en/latest/Cheaper.html

### deploying flask example
# uwsgi --socket 127.0.0.1:3031 --wsgi-file myflaskapp.py --callable app --processes 4 --threads 2 --stats 127.0.0.1:9191
# The stats subsystem allows you to export uWSGI’s internal statistics as JSON. Make some request to your app and then telnet
# to the port 9191, you’ll get lots of fun information. You may want to use “uwsgitop”
# uwsgi --socket 127.0.0.1:10110/api --wsgi-file runserver.py --callable app --processes 2 --stats 127.0.0.1:9191



