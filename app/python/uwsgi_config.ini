[uwsgi]
master = true ; false makes sense for debugging with e.g. Valgrind
strict = true ; Fail if unknown config parameter found
enable-threads = false ; Python threads not allowed (don't need them)
vacuum = true ; delete sockets during shutdown. Cleanup after yourself
single-interpreter = true ; single python interpreter per worker instance
die-on-term = true ; Shutdown when receiving SIGTERM
need-app = true ; Fail to start if application cannot load
;disable-logging = true ; uWSGI logging is too verbose
;log-4xx = true ; but we want to see critical errors
;log-5xx = true ; but we want to see critical errors
req-logger = file:log_uwsgi_requests.txt
logger = file:log_uwsgi_error.txt
auto-procname = true ; give processes names (master and worker)
; prepend a useful name to these names
procname-prefix = agotool_flaskapp_
; loads your application one time per worker. thereby forking is disabled.
lazy-apps = true

;PythonHome = /mnt/mnemo5/dblyon/install/anaconda3/envs/agotool/bin/uwsgi
wsgi-file = runserver.py
callable = app
http = 127.0.0.1:10110 # incoming connections
stats = 127.0.0.1:9191 # monitor

; ### When to restart workers
max-requests = 10000 ; Restart workers after this many requests
max-worker-lifetime = 604800 ; Restart workers after this many seconds (604800 --> 24*7*60*60, once per week).
;cheaper = 2 ; Minimum number of workers allowed
;processes = 2 ; Maximum number of workers allowed

;reload-on-rss = 10240 ; Restart workers after this much resident memory (10GB)
;worker-reload-mercy = 60 ; How long to wait before forcefully killing workers

### This configuration will tell uWSGI to run up to 10 workers under load. If the app is idle uWSGI will stop workers but it will always leave at least 2 of them running.
# set cheaper algorithm to use, if not set default will be used
;cheaper-algo = spare
;# minimum number of workers to keep at all times
;cheaper = 2
;# number of workers to spawn at startup
;cheaper-initial = 2
;# maximum number of workers that can be spawned
;workers = 4
;# how many workers should be spawned at a time
;cheaper-step = 2

;; ### Dynamic worker scaling
cheaper-algo = busyness
processes = 4 ; Maximum number of workers allowed
cheaper = 2 ; Minimum number of workers allowed
cheaper-initial = 2 ; Workers created at startup
cheaper-overload = 60 ; Length of a cycle in seconds
cheaper-step = 2 ; How many workers to spawn at a time
cheaper-busyness-multiplier = 60 ; How many cycles to wait before killing workers
cheaper-busyness-min = 20 ; Below this threshold, kill workers (if stable for multiplier cycles).
cheaper-busyness-max = 70 ; Above this threshold, spawn new workers
cheaper-busyness-backlog-alert = 16 ; Spawn emergency workers if more than this many requests are waiting in the queue
cheaper-busyness-backlog-step = 2 ; How many emergegency workers to create if there are too many requests in the queue